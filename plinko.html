<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Riskit.com Plinko</title>
    <style>
        /* Modern styling matching slots.html */
        body {
            background-color: #1a2c3a;
            color: white;
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .container {
            text-align: center;
            max-width: 800px;
            width: 100%;
        }

        h1 {
            margin-bottom: 30px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }

        .balance-section {
            background: rgba(255,255,255,0.1);
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 30px;
            backdrop-filter: blur(10px);
        }

        .balance {
            font-size: 1.5em;
            font-weight: bold;
            color: #4CAF50;
        }

        .plinko-board-container {
            margin: 40px 0;
            background: rgba(0,0,0,0.18);
            border-radius: 16px;
            padding: 28px 32px;
            backdrop-filter: blur(10px);
            max-width: 780px;
            width: 100%;
        }

        #plinkoBoard {
            display: block;
            margin: 0 auto;
            border-radius: 18px;
            box-shadow: 0 10px 35px rgba(0,0,0,0.32);
            max-width: 100%;
        }

        .bet-section {
            margin: 30px 0;
            padding: 20px;
            background: rgba(255,255,255,0.1);
            border-radius: 10px;
            backdrop-filter: blur(10px);
        }

        input {
            padding: 10px;
            font-size: 16px;
            border: 2px solid #555;
            border-radius: 5px;
            background: rgba(255,255,255,0.1);
            color: white;
            margin: 10px;
        }

        input:focus {
            outline: none;
            border-color: #4CAF50;
        }

        button {
            padding: 12px 30px;
            font-size: 18px;
            cursor: pointer;
            background: linear-gradient(45deg, #4CAF50, #45a049);
            color: white;
            border: none;
            border-radius: 25px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(76, 175, 80, 0.3);
            font-weight: bold;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(76, 175, 80, 0.4);
        }

        button:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .results {
            margin-top: 30px;
            padding: 20px;
            background: rgba(255,255,255,0.1);
            border-radius: 10px;
            min-height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .win {
            color: #4CAF50;
            font-size: 1.2em;
            font-weight: bold;
        }

        .lose {
            color: #f44336;
            font-size: 1.2em;
        }

        .rules {
            margin-top: 40px;
            padding: 20px;
            background: rgba(255,255,255,0.1);
            border-radius: 10px;
            backdrop-filter: blur(10px);
        }

        .rules h2 {
            color: #4CAF50;
            margin-bottom: 15px;
        }

        .rules p {
            margin: 8px 0;
            line-height: 1.6;
        }

        @media (max-width: 600px) {
            #plinkoBoard {
                width: 340px !important;
                height: 510px !important;
            }

            h1 {
                font-size: 2em;
            }

            button {
                padding: 10px 20px;
                font-size: 16px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ü™ê Riskit.com Plinko ü™ê</h1>

        <div class="balance-section">
            <p>Balance: $<span class="balance" id="balance">10000.00</span></p>
        </div>

        <div class="plinko-board-container">
            <canvas id="plinkoBoard" width="600" height="720"></canvas>
        </div>

        <div class="bet-section">
            <input type="number" id="betAmount" placeholder="Enter bet amount" min="1">
            <input type="number" id="ballCount" placeholder="Number of balls" min="1" value="1">
            <button id="placeBetButton" onclick="placeBet()">ü™ê Place Bet ü™ê</button>
        </div>

        <div class="results" id="result">
            <p>Place your bet and watch the ball fall!</p>
        </div>
    </div>

    <div class="rules">
        <h2>üìã Rules:</h2>
        <p>1. üéØ Place your bet amount</p>
        <p>2. ü™ê Click "Place Bet" to drop the ball</p>
        <p>3. üí∞ Watch the ball bounce through the pegs</p>
        <p>4. üèÜ Land on higher multipliers to win more!</p>
        <p>5. ‚ùå Different slots have different payouts</p>
    </div>

    <script>
        const canvas = document.getElementById('plinkoBoard');
        const ctx = canvas.getContext('2d');
        const rows = 10;
        const cols = 9;
        const pegRadius = 5;
        const ballRadius = 10;
        const multipliers = [
            1000, 100, 50, 10, 5,
            2, 1.5, 1, 0.5, 0,
            0.5, 1, 1.5, 2, 5,
            10, 50, 100, 1000
        ];
        const boardBottom = canvas.height - 80;
        const slotCount = multipliers.length;
        const slotWidth = canvas.width / slotCount;
        const COLOR_LOW_MULTIPLIER = '#ffd54f';
        const COLOR_HIGH_MULTIPLIER = '#ff1744';
        const uniqueMultipliers = [...new Set(multipliers)].sort((a, b) => a - b);
        const slotColors = multipliers.map(multiplier => multiplierToColor(multiplier));
        const slotGlows = new Array(slotCount).fill(0);

        let balance = 10000;
        let balls = [];
        let animationId = null;
        let roundCounter = 0;
        let roundState = null;
        let dropping = false;

        const physics = {
            gravity: 0.3,
            airDrag: 0.995,
            pegBounce: 0.75,
            wallBounce: 0.6,
            floorBounce: 0.35,
            floorFriction: 0.92,
            settleVelocity: 0.35
        };

        const resultEl = document.getElementById('result');
        const balanceEl = document.getElementById('balance');
        const dropButton = document.getElementById('placeBetButton');
        const ballCountInput = document.getElementById('ballCount');

        const pegs = createPegs();

        drawBoard();
        updateBalance();

        function createPegs() {
            const positions = [];
            const verticalSpacing = boardBottom / (rows + 1);
            for (let row = 0; row < rows; row++) {
                const columnsInRow = cols - (row % 2);
                for (let column = 0; column < columnsInRow; column++) {
                    const x = (column * canvas.width) / (cols - 1) + ((row % 2) * canvas.width) / (cols * 2);
                    const y = (row + 1) * verticalSpacing;
                    positions.push({ x, y });
                }
            }
            return positions;
        }

        function updateBalance() {
            balanceEl.innerText = balance.toFixed(2);
        }

        function drawBoard() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            const frameGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            frameGradient.addColorStop(0, '#081321');
            frameGradient.addColorStop(1, '#0f1f33');
            ctx.fillStyle = frameGradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.save();
            const playAreaGradient = ctx.createLinearGradient(0, 0, 0, boardBottom);
            playAreaGradient.addColorStop(0, 'rgba(22, 44, 72, 0.95)');
            playAreaGradient.addColorStop(1, 'rgba(12, 27, 44, 0.95)');
            ctx.fillStyle = playAreaGradient;
            ctx.fillRect(0, 0, canvas.width, boardBottom);
            ctx.restore();

            ctx.save();
            ctx.fillStyle = 'rgba(255, 255, 255, 0.03)';
            ctx.fillRect(0, boardBottom, canvas.width, canvas.height - boardBottom);
            ctx.restore();

            for (let i = 0; i < slotGlows.length; i++) {
                if (slotGlows[i] > 0) {
                    slotGlows[i] *= 0.9;
                    if (slotGlows[i] < 0.02) {
                        slotGlows[i] = 0;
                    }
                }
            }

            ctx.save();
            ctx.globalCompositeOperation = 'lighter';
            for (let i = 0; i < slotGlows.length; i++) {
                const rawIntensity = slotGlows[i];
                if (rawIntensity <= 0) {
                    continue;
                }

                const intensity = Math.min(1.5, rawIntensity);
                const slotX = i * slotWidth;
                const centerX = slotX + slotWidth / 2;
                const glowTop = Math.max(0, boardBottom - 70);
                const glowBottom = canvas.height;
                const color = slotColors[i];
                const primaryAlpha = 0.4 * intensity;
                const secondaryAlpha = 0.18 * intensity;

                const gradient = ctx.createLinearGradient(centerX, glowTop, centerX, glowBottom);
                gradient.addColorStop(0, rgbaFromColor(color, 0));
                gradient.addColorStop(0.55, rgbaFromColor(color, secondaryAlpha));
                gradient.addColorStop(1, rgbaFromColor(color, primaryAlpha));
                ctx.fillStyle = gradient;
                ctx.fillRect(slotX, glowTop, slotWidth, glowBottom - glowTop);

                ctx.beginPath();
                ctx.ellipse(centerX, boardBottom + 16, slotWidth * 0.4, 16, 0, 0, Math.PI * 2);
                ctx.fillStyle = rgbaFromColor(color, Math.min(0.65, 0.35 * intensity));
                ctx.fill();
            }
            ctx.restore();

            ctx.fillStyle = '#d7e4ff';
            for (const peg of pegs) {
                ctx.beginPath();
                ctx.arc(peg.x, peg.y, pegRadius, 0, Math.PI * 2);
                ctx.fill();
                ctx.closePath();
            }

            ctx.strokeStyle = 'rgba(255,255,255,0.15)';
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.moveTo(0, boardBottom);
            ctx.lineTo(canvas.width, boardBottom);
            ctx.stroke();

            for (let i = 0; i <= slotCount; i++) {
                const x = i * slotWidth;
                ctx.beginPath();
                ctx.moveTo(x, boardBottom);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }

            ctx.font = '12px Arial';
            ctx.fillStyle = 'rgba(255,255,255,0.85)';
            ctx.textAlign = 'center';
            for (let i = 0; i < multipliers.length; i++) {
                const x = i * slotWidth + slotWidth / 2;
                ctx.fillText(`${multipliers[i]}x`, x, canvas.height - 20);
            }
        }

        function placeBet() {
            if (dropping) {
                alert('Balls are still in play. Please wait for them to settle before placing another bet.');
                return;
            }

            const betAmount = parseFloat(document.getElementById('betAmount').value);
            const ballCount = parseInt(ballCountInput.value, 10);

            if (Number.isNaN(betAmount) || betAmount <= 0) {
                alert('Please enter a valid bet amount.');
                return;
            }

            if (Number.isNaN(ballCount) || ballCount <= 0) {
                alert('Please enter how many balls to drop (at least 1).');
                return;
            }

            const totalBet = betAmount * ballCount;

            if (totalBet > balance) {
                alert('Insufficient funds. Please enter a lower bet amount or fewer balls.');
                return;
            }

            balance -= totalBet;
            updateBalance();

            roundState = {
                id: ++roundCounter,
                count: ballCount,
                resolved: 0,
                totalBet,
                totalWinnings: 0,
                betAmount,
                messages: []
            };

            dropping = true;
            dropButton.disabled = true;
            resultEl.innerText = `Dropping ${ballCount} ball${ballCount > 1 ? 's' : ''} at $${betAmount.toFixed(2)} each...`;

            dropBalls(betAmount, ballCount, roundState.id);
        }

        function dropBalls(betAmount, count, roundId) {
            const spread = Math.min(120, (count - 1) * ballRadius * 2.2);
            for (let i = 0; i < count; i++) {
                const offset = count === 1 ? 0 : -spread / 2 + (spread / (count - 1)) * i;
                const ball = {
                    x: Math.min(canvas.width - ballRadius, Math.max(ballRadius, canvas.width / 2 + offset)),
                    y: ballRadius * 2,
                    vx: (Math.random() - 0.5) * 1.2,
                    vy: 0,
                    betAmount,
                    roundId,
                    resultApplied: false,
                    finished: false,
                    settleFrames: 0,
                    remove: false
                };
                balls.push(ball);
            }

            if (!animationId) {
                animationId = requestAnimationFrame(animate);
            }
        }

        function animate() {
            animationId = requestAnimationFrame(animate);
            drawBoard();

            for (const ball of balls) {
                updateBall(ball);
                drawBall(ball);
            }

            balls = balls.filter(ball => !ball.remove);

            if (!balls.length) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
        }

        function updateBall(ball) {
            if (ball.remove) {
                return;
            }

            if (ball.finished) {
                ball.settleFrames += 1;
                if (ball.settleFrames > 45) {
                    ball.remove = true;
                }
                return;
            }

            ball.vy += physics.gravity;
            ball.vx *= physics.airDrag;
            ball.vy *= physics.airDrag;

            ball.x += ball.vx;
            ball.y += ball.vy;

            if (handleOffBoard(ball)) {
                return;
            }

            handlePegCollisions(ball);
            handleBottomCollision(ball);
        }

        function handleOffBoard(ball) {
            const fullyOutside = ball.x + ballRadius < 0 || ball.x - ballRadius > canvas.width;
            const centerOutside = ball.x < 0 || ball.x > canvas.width;

            if (!fullyOutside && !centerOutside) {
                return false;
            }

            handleBallOffBoard(ball);
            return true;
        }

        function handleBallOffBoard(ball) {
            finalizeBallResult(ball, 0, (ballNumber) => `Ball ${ballNumber}: Off board ‚Üí $0.00`);
            ball.remove = true;
        }

        function handlePegCollisions(ball) {
            for (const peg of pegs) {
                const distX = ball.x - peg.x;
                const distY = ball.y - peg.y;
                const dist = Math.hypot(distX, distY);
                const minDist = pegRadius + ballRadius;

                if (dist < minDist) {
                    const normalX = dist !== 0 ? distX / dist : (Math.random() - 0.5);
                    const normalY = dist !== 0 ? distY / dist : (Math.random() - 0.5);
                    const penetration = minDist - dist;

                    ball.x += normalX * penetration;
                    ball.y += normalY * penetration;

                    const relativeVelocity = ball.vx * normalX + ball.vy * normalY;
                    if (relativeVelocity < 0) {
                        const impulse = -(1 + physics.pegBounce) * relativeVelocity;
                        ball.vx += impulse * normalX;
                        ball.vy += impulse * normalY;
                    }

                    const tangentX = -normalY;
                    const tangentY = normalX;
                    const tangentVelocity = ball.vx * tangentX + ball.vy * tangentY;
                    const randomTilt = (Math.random() - 0.5) * 0.18;
                    ball.vx += (randomTilt - tangentVelocity * 0.15) * tangentX;
                    ball.vy += (randomTilt - tangentVelocity * 0.15) * tangentY;
                }
            }
        }

        function handleBottomCollision(ball) {
            if (ball.y + ballRadius < boardBottom) {
                return;
            }

            ball.y = boardBottom - ballRadius;

            if (ball.x < 0 || ball.x > canvas.width) {
                handleBallOffBoard(ball);
                return;
            }

            const slotIndex = clampSlotIndex(ball.x);

            if (Math.abs(ball.vy) < physics.settleVelocity && Math.abs(ball.vx) < physics.settleVelocity) {
                settleBall(ball, slotIndex);
                return;
            }

            ball.vy = -ball.vy * physics.floorBounce;
            ball.vx *= physics.floorFriction;

            if (Math.abs(ball.vy) < physics.settleVelocity) {
                ball.vy = 0;
            }
        }

        function settleBall(ball, slotIndex) {
            if (ball.resultApplied) {
                return;
            }

            const multiplier = multipliers[slotIndex];
            triggerSlotGlow(slotIndex);
            finalizeBallResult(ball, multiplier);
        }

        function triggerSlotGlow(slotIndex) {
            if (slotIndex < 0 || slotIndex >= slotGlows.length) {
                return;
            }

            slotGlows[slotIndex] = Math.min(1.25, slotGlows[slotIndex] + 0.85);
        }

        function finalizeBallResult(ball, multiplier, messageFactory) {
            if (ball.resultApplied) {
                return;
            }

            ball.resultApplied = true;
            ball.finished = true;
            ball.vx = 0;
            ball.vy = 0;

            const winnings = ball.betAmount * multiplier;

            balance += winnings;
            updateBalance();

            if (roundState && ball.roundId === roundState.id) {
                const ballNumber = roundState.resolved + 1;
                roundState.resolved = ballNumber;
                roundState.totalWinnings += winnings;

                const message = typeof messageFactory === 'function'
                    ? messageFactory(ballNumber, winnings, multiplier)
                    : `Ball ${ballNumber}: ${multiplier}x ‚Üí $${winnings.toFixed(2)}`;
                roundState.messages.push(message);
                updateRoundDisplay();
            }
        }

        function updateRoundDisplay() {
            if (!roundState) {
                return;
            }

            const lines = [...roundState.messages];
            if (roundState.resolved < roundState.count) {
                const remaining = roundState.count - roundState.resolved;
                lines.push(`Awaiting ${remaining} more ball${remaining > 1 ? 's' : ''}...`);
            } else {
                const net = roundState.totalWinnings - roundState.totalBet;
                const netLabel = net >= 0 ? 'Profit' : 'Loss';
                lines.push(`Total returned: $${roundState.totalWinnings.toFixed(2)} (${netLabel} ${net >= 0 ? '+' : '-'}$${Math.abs(net).toFixed(2)})`);
                dropButton.disabled = false;
                dropping = false;
            }

            resultEl.innerText = lines.join('\n');
        }

        function clampSlotIndex(x) {
            const clampedX = Math.min(canvas.width - 0.0001, Math.max(0, x));
            return Math.min(slotCount - 1, Math.max(0, Math.floor(clampedX / slotWidth)));
        }

        function drawBall(ball) {
            ctx.save();
            ctx.beginPath();
            const gradient = ctx.createRadialGradient(
                ball.x - ballRadius / 3,
                ball.y - ballRadius / 3,
                ballRadius / 6,
                ball.x,
                ball.y,
                ballRadius
            );
            gradient.addColorStop(0, '#ffe0a0');
            gradient.addColorStop(1, '#ff6584');
            ctx.fillStyle = gradient;
            ctx.shadowColor = 'rgba(255, 110, 130, 0.45)';
            ctx.shadowBlur = 10;
            ctx.arc(ball.x, ball.y, ballRadius, 0, Math.PI * 2);
            ctx.fill();
            ctx.closePath();
            ctx.restore();
        }

        function multiplierToColor(multiplier) {
            const rank = uniqueMultipliers.indexOf(multiplier);
            const t = uniqueMultipliers.length > 1 ? rank / (uniqueMultipliers.length - 1) : 0;
            return lerpColors(COLOR_LOW_MULTIPLIER, COLOR_HIGH_MULTIPLIER, t);
        }

        function lerpColors(hexA, hexB, t) {
            const colorA = hexToRgb(hexA);
            const colorB = hexToRgb(hexB);
            return {
                r: Math.round(colorA.r + (colorB.r - colorA.r) * t),
                g: Math.round(colorA.g + (colorB.g - colorA.g) * t),
                b: Math.round(colorA.b + (colorB.b - colorA.b) * t)
            };
        }

        function hexToRgb(hex) {
            const normalized = hex.replace('#', '');
            const expanded = normalized.length === 3
                ? normalized.split('').map(char => char + char).join('')
                : normalized;

            return {
                r: parseInt(expanded.slice(0, 2), 16),
                g: parseInt(expanded.slice(2, 4), 16),
                b: parseInt(expanded.slice(4, 6), 16)
            };
        }

        function rgbaFromColor(color, alpha) {
            return `rgba(${color.r}, ${color.g}, ${color.b}, ${alpha})`;
        }
    </script>
</body>
</html>

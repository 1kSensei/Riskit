<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Riskit.com Plinko</title>
    <style>
        /* Modern styling matching slots.html */
        body {
            background-color: #1a2c3a;
            color: white;
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .container {
            text-align: center;
            max-width: 800px;
            width: 100%;
        }

        h1 {
            margin-bottom: 30px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }

        .balance-section {
            background: rgba(255,255,255,0.1);
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 30px;
            backdrop-filter: blur(10px);
        }

        .balance {
            font-size: 1.5em;
            font-weight: bold;
            color: #4CAF50;
        }

        .plinko-board-container {
            margin: 40px 0;
            background: rgba(0,0,0,0.2);
            border-radius: 10px;
            padding: 20px;
            backdrop-filter: blur(10px);
        }

        #plinkoBoard {
            background-color: #1a2c3a;
            border: 2px solid rgba(255,255,255,0.2);
            border-radius: 10px;
            box-shadow: 0 8px 25px rgba(0,0,0,0.3);
        }

        .bet-section {
            margin: 30px 0;
            padding: 20px;
            background: rgba(255,255,255,0.1);
            border-radius: 10px;
            backdrop-filter: blur(10px);
        }

        input {
            padding: 10px;
            font-size: 16px;
            border: 2px solid #555;
            border-radius: 5px;
            background: rgba(255,255,255,0.1);
            color: white;
            margin: 10px;
        }

        input:focus {
            outline: none;
            border-color: #4CAF50;
        }

        button {
            padding: 12px 30px;
            font-size: 18px;
            cursor: pointer;
            background: linear-gradient(45deg, #4CAF50, #45a049);
            color: white;
            border: none;
            border-radius: 25px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(76, 175, 80, 0.3);
            font-weight: bold;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(76, 175, 80, 0.4);
        }

        button:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .results {
            margin-top: 30px;
            padding: 20px;
            background: rgba(255,255,255,0.1);
            border-radius: 10px;
            min-height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .win {
            color: #4CAF50;
            font-size: 1.2em;
            font-weight: bold;
        }

        .lose {
            color: #f44336;
            font-size: 1.2em;
        }

        .rules {
            margin-top: 40px;
            padding: 20px;
            background: rgba(255,255,255,0.1);
            border-radius: 10px;
            backdrop-filter: blur(10px);
        }

        .rules h2 {
            color: #4CAF50;
            margin-bottom: 15px;
        }

        .rules p {
            margin: 8px 0;
            line-height: 1.6;
        }

        @media (max-width: 600px) {
            #plinkoBoard {
                width: 300px !important;
                height: 450px !important;
            }

            h1 {
                font-size: 2em;
            }

            button {
                padding: 10px 20px;
                font-size: 16px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ü™ê Riskit.com Plinko ü™ê</h1>

        <div class="balance-section">
            <p>Balance: $<span class="balance" id="balance">10000.00</span></p>
        </div>

        <div class="plinko-board-container">
            <canvas id="plinkoBoard" width="400" height="600"></canvas>
        </div>

        <div class="bet-section">
            <input type="number" id="betAmount" placeholder="Enter bet amount" min="1">
            <input type="number" id="ballCount" placeholder="Number of balls" min="1" value="1">
            <button id="placeBetButton" onclick="placeBet()">ü™ê Place Bet ü™ê</button>
        </div>

        <div class="results" id="result">
            <p>Place your bet and watch the ball fall!</p>
        </div>
    </div>

    <div class="rules">
        <h2>üìã Rules:</h2>
        <p>1. üéØ Place your bet amount</p>
        <p>2. ü™ê Click "Place Bet" to drop the ball</p>
        <p>3. üí∞ Watch the ball bounce through the pegs</p>
        <p>4. üèÜ Land on higher multipliers to win more!</p>
        <p>5. ‚ùå Different slots have different payouts</p>
    </div>

    <script>
        const canvas = document.getElementById('plinkoBoard');
        const ctx = canvas.getContext('2d');
        const rows = 10;
        const cols = 9;
        const pegRadius = 5;
        const ballRadius = 10;
        const multipliers = [5, 2, 1.5, 1, 0.5, 0, 0.5, 1, 1.5, 2, 5];
        const boardBottom = canvas.height - 80;
        const slotCount = multipliers.length;
        const slotWidth = canvas.width / slotCount;

        let balance = 10000;
        let balls = [];
        let animationId = null;
        let roundCounter = 0;
        let roundState = null;
        let dropping = false;

        const physics = {
            gravity: 0.3,
            airDrag: 0.995,
            pegBounce: 0.75,
            wallBounce: 0.6,
            floorBounce: 0.35,
            floorFriction: 0.92,
            settleVelocity: 0.35
        };

        const resultEl = document.getElementById('result');
        const balanceEl = document.getElementById('balance');
        const dropButton = document.getElementById('placeBetButton');
        const ballCountInput = document.getElementById('ballCount');

        const pegs = createPegs();

        drawBoard();
        updateBalance();

        function createPegs() {
            const positions = [];
            const verticalSpacing = boardBottom / (rows + 1);
            for (let row = 0; row < rows; row++) {
                const columnsInRow = cols - (row % 2);
                for (let column = 0; column < columnsInRow; column++) {
                    const x = (column * canvas.width) / (cols - 1) + ((row % 2) * canvas.width) / (cols * 2);
                    const y = (row + 1) * verticalSpacing;
                    positions.push({ x, y });
                }
            }
            return positions;
        }

        function updateBalance() {
            balanceEl.innerText = balance.toFixed(2);
        }

        function drawBoard() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#1a2c3a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.save();
            ctx.fillStyle = 'rgba(255,255,255,0.05)';
            ctx.fillRect(0, 0, canvas.width, boardBottom);
            ctx.restore();

            ctx.fillStyle = '#b1bad3';
            for (const peg of pegs) {
                ctx.beginPath();
                ctx.arc(peg.x, peg.y, pegRadius, 0, Math.PI * 2);
                ctx.fill();
                ctx.closePath();
            }

            ctx.strokeStyle = 'rgba(255,255,255,0.2)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(0, boardBottom);
            ctx.lineTo(canvas.width, boardBottom);
            ctx.stroke();

            for (let i = 0; i <= slotCount; i++) {
                const x = i * slotWidth;
                ctx.beginPath();
                ctx.moveTo(x, boardBottom);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }

            ctx.font = '16px Arial';
            ctx.fillStyle = '#ffffff';
            ctx.textAlign = 'center';
            for (let i = 0; i < multipliers.length; i++) {
                const x = i * slotWidth + slotWidth / 2;
                ctx.fillText(`${multipliers[i]}x`, x, canvas.height - 20);
            }
        }

        function placeBet() {
            if (dropping) {
                alert('Balls are still in play. Please wait for them to settle before placing another bet.');
                return;
            }

            const betAmount = parseFloat(document.getElementById('betAmount').value);
            const ballCount = parseInt(ballCountInput.value, 10);

            if (Number.isNaN(betAmount) || betAmount <= 0) {
                alert('Please enter a valid bet amount.');
                return;
            }

            if (Number.isNaN(ballCount) || ballCount <= 0) {
                alert('Please enter how many balls to drop (at least 1).');
                return;
            }

            const totalBet = betAmount * ballCount;

            if (totalBet > balance) {
                alert('Insufficient funds. Please enter a lower bet amount or fewer balls.');
                return;
            }

            balance -= totalBet;
            updateBalance();

            roundState = {
                id: ++roundCounter,
                count: ballCount,
                resolved: 0,
                totalBet,
                totalWinnings: 0,
                betAmount,
                messages: []
            };

            dropping = true;
            dropButton.disabled = true;
            resultEl.innerText = `Dropping ${ballCount} ball${ballCount > 1 ? 's' : ''} at $${betAmount.toFixed(2)} each...`;

            dropBalls(betAmount, ballCount, roundState.id);
        }

        function dropBalls(betAmount, count, roundId) {
            const spread = Math.min(120, (count - 1) * ballRadius * 2.2);
            for (let i = 0; i < count; i++) {
                const offset = count === 1 ? 0 : -spread / 2 + (spread / (count - 1)) * i;
                const ball = {
                    x: Math.min(canvas.width - ballRadius, Math.max(ballRadius, canvas.width / 2 + offset)),
                    y: ballRadius * 2,
                    vx: (Math.random() - 0.5) * 1.2,
                    vy: 0,
                    betAmount,
                    roundId,
                    resultApplied: false,
                    finished: false,
                    settleFrames: 0,
                    remove: false
                };
                balls.push(ball);
            }

            if (!animationId) {
                animationId = requestAnimationFrame(animate);
            }
        }

        function animate() {
            animationId = requestAnimationFrame(animate);
            drawBoard();

            for (const ball of balls) {
                updateBall(ball);
                drawBall(ball);
            }

            balls = balls.filter(ball => !ball.remove);

            if (!balls.length) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
        }

        function updateBall(ball) {
            if (ball.remove) {
                return;
            }

            if (ball.finished) {
                ball.settleFrames += 1;
                if (ball.settleFrames > 45) {
                    ball.remove = true;
                }
                return;
            }

            ball.vy += physics.gravity;
            ball.vx *= physics.airDrag;
            ball.vy *= physics.airDrag;

            ball.x += ball.vx;
            ball.y += ball.vy;

            handleWallCollisions(ball);
            handlePegCollisions(ball);
            handleBottomCollision(ball);
        }

        function handleWallCollisions(ball) {
            if (ball.x - ballRadius < 0) {
                ball.x = ballRadius;
                ball.vx = Math.abs(ball.vx) * physics.wallBounce;
            } else if (ball.x + ballRadius > canvas.width) {
                ball.x = canvas.width - ballRadius;
                ball.vx = -Math.abs(ball.vx) * physics.wallBounce;
            }
        }

        function handlePegCollisions(ball) {
            for (const peg of pegs) {
                const distX = ball.x - peg.x;
                const distY = ball.y - peg.y;
                const dist = Math.hypot(distX, distY);
                const minDist = pegRadius + ballRadius;

                if (dist < minDist) {
                    const normalX = dist !== 0 ? distX / dist : (Math.random() - 0.5);
                    const normalY = dist !== 0 ? distY / dist : (Math.random() - 0.5);
                    const penetration = minDist - dist;

                    ball.x += normalX * penetration;
                    ball.y += normalY * penetration;

                    const relativeVelocity = ball.vx * normalX + ball.vy * normalY;
                    if (relativeVelocity < 0) {
                        const impulse = -(1 + physics.pegBounce) * relativeVelocity;
                        ball.vx += impulse * normalX;
                        ball.vy += impulse * normalY;
                    }

                    const tangentX = -normalY;
                    const tangentY = normalX;
                    const tangentVelocity = ball.vx * tangentX + ball.vy * tangentY;
                    const randomTilt = (Math.random() - 0.5) * 0.18;
                    ball.vx += (randomTilt - tangentVelocity * 0.15) * tangentX;
                    ball.vy += (randomTilt - tangentVelocity * 0.15) * tangentY;
                }
            }
        }

        function handleBottomCollision(ball) {
            if (ball.y + ballRadius < boardBottom) {
                return;
            }

            ball.y = boardBottom - ballRadius;
            const slotIndex = clampSlotIndex(ball.x);
            constrainWithinSlot(ball, slotIndex);

            if (Math.abs(ball.vy) < physics.settleVelocity && Math.abs(ball.vx) < physics.settleVelocity) {
                settleBall(ball, slotIndex);
                return;
            }

            ball.vy = -ball.vy * physics.floorBounce;
            ball.vx *= physics.floorFriction;

            if (Math.abs(ball.vy) < physics.settleVelocity) {
                ball.vy = 0;
            }
        }

        function constrainWithinSlot(ball, slotIndex) {
            const leftBoundary = slotIndex * slotWidth + ballRadius;
            const rightBoundary = (slotIndex + 1) * slotWidth - ballRadius;

            if (ball.x < leftBoundary) {
                ball.x = leftBoundary;
                ball.vx = Math.abs(ball.vx) * physics.wallBounce;
            } else if (ball.x > rightBoundary) {
                ball.x = rightBoundary;
                ball.vx = -Math.abs(ball.vx) * physics.wallBounce;
            }
        }

        function settleBall(ball, slotIndex) {
            if (ball.resultApplied) {
                return;
            }

            ball.resultApplied = true;
            ball.finished = true;
            ball.vx = 0;
            ball.vy = 0;

            const multiplier = multipliers[slotIndex];
            const winnings = ball.betAmount * multiplier;

            balance += winnings;
            updateBalance();

            if (roundState && ball.roundId === roundState.id) {
                roundState.resolved += 1;
                roundState.totalWinnings += winnings;
                roundState.messages.push(`Ball ${roundState.resolved}: ${multiplier}x ‚Üí $${winnings.toFixed(2)}`);
                updateRoundDisplay();
            }
        }

        function updateRoundDisplay() {
            if (!roundState) {
                return;
            }

            const lines = [...roundState.messages];
            if (roundState.resolved < roundState.count) {
                const remaining = roundState.count - roundState.resolved;
                lines.push(`Awaiting ${remaining} more ball${remaining > 1 ? 's' : ''}...`);
            } else {
                const net = roundState.totalWinnings - roundState.totalBet;
                const netLabel = net >= 0 ? 'Profit' : 'Loss';
                lines.push(`Total returned: $${roundState.totalWinnings.toFixed(2)} (${netLabel} ${net >= 0 ? '+' : '-'}$${Math.abs(net).toFixed(2)})`);
                dropButton.disabled = false;
                dropping = false;
            }

            resultEl.innerText = lines.join('\n');
        }

        function clampSlotIndex(x) {
            const clampedX = Math.min(canvas.width - 0.0001, Math.max(0, x));
            return Math.min(slotCount - 1, Math.max(0, Math.floor(clampedX / slotWidth)));
        }

        function drawBall(ball) {
            ctx.beginPath();
            const gradient = ctx.createRadialGradient(
                ball.x - ballRadius / 3,
                ball.y - ballRadius / 3,
                ballRadius / 5,
                ball.x,
                ball.y,
                ballRadius
            );
            gradient.addColorStop(0, '#ffefba');
            gradient.addColorStop(1, '#ff5f6d');
            ctx.fillStyle = gradient;
            ctx.arc(ball.x, ball.y, ballRadius, 0, Math.PI * 2);
            ctx.fill();
            ctx.closePath();
        }
    </script>
</body>
</html>
